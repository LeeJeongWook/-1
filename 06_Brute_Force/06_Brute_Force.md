06 무식하게 풀기

6.1 도입
복잡하지만 우아한 알고리즘을 만들고 싶은 마음이 커지면서 쉽고 간단하며 틀릴 가능성이 낮은 답안을 간과하기 쉬워진다.

완전 탐색(Exhaustive Search) : 가능한 방법을 전부 만들어 보는 알고리즘

6.2 재귀 호출과 완전 탐색 (Code: 6.1 ~ )
**재귀호출**
수행할 작업을 유사한 형태의 여러 조각으로 쪼갠 뒤 그 중 한 조각을 수행하고, 나머지를 자기 자신을 호출해 실행하는 함수이다.

모든 재귀 함수는 '더 이상 쪼개지지 않는' 최소한의 작업에 도달했을 때 답을 곧장 반환하는 조건문을 포함해야 된다.
이때, 쪼개지지 않는 가장 작은 작업들을 가리켜 재귀 호출의 기저 사례(Base case)라고 한다.

**시간 복잡도 분석**
완전 탐색은 가능한 답 후보들을 모두 만들어 보기 때문에, 시간 복잡도를 계산하기 위해서는 가능한 후보의 수를 전부 세어보기만 하면 된다.

**완전 탐색 레시피**
어떤 문제를 완전 탐색으로 해결하기 위해 필요한 과정은 대략 다음과 같다.
1. 완전 탐색은 존재하는 모든 답을 하나씩 검사하므로, 걸리는 시간은 가능한 답의 수에 정확히 비례한다.
2. 가능한 모든 답의 후보를 만드는 과정을 여러 개의 선택으로 나눈다.
3. 그중 하나의 조각을 선택해 답의 일부를 만들고, 나머지 답을 재귀 호출을 통해 완성한다.
4. 조각이 하나밖에 남지 않은 경우, 혹은 하나도 남지 않은 경우에는 답을 생성했으므로, 이것을 기저 사례로 선택해 처리한다.

**이론적 배경: 재귀 호출과 부분 문제**
재귀 호출 주요 개념중 하나로 문제(Problem)와 부분 문제(Subproblem)의 정의가 있다.
이 정의는 뒤에 다룰 동적 계획법이나 분할 정복과 같은 중요한 디자인 패러다임을 설명하는 데 사용된다.

6.3 문제: 소풍 (문제 ID: PICNIC, 난이도: 하)
6.4 풀이: 소풍
6.5 문제: 게임판 덮기 (문제 ID: BOARDCOVER, 난이도: 하)
6.6 풀이: 게임판 덮기

6.7 최적화 문제
어떤 기준에 따라 가장 '좋은' 답을 찾아 내는 문제들을 통칭해 최적화 문제(Optimization problem)라고 부른다.
Ex. n개의 원소 중에서 r개를 순서 없이 골라내는 방법의 수를 계산하기 (x)
    n개의 사과 중에서 r개를 골라서 무게의 합을 최대화하는 문제 (o)