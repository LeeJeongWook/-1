# 06 무식하게 풀기

## 6.1 도입
복잡하지만 우아한 알고리즘을 만들고 싶은 마음이 커지면서 쉽고 간단하며 틀릴 가능성이 낮은 답안을 간과하기 쉬워진다.

**[완전 탐색(Exhaustive Search)]** : 가능한 방법을 전부 만들어 보는 알고리즘
<br></br>

## 6.2 재귀 호출과 완전 탐색 (Code: 6.1 ~ )
**[재귀 호출]**  
수행할 작업을 유사한 형태의 여러 조각으로 쪼갠 뒤 그 중 한 조각을 수행하고, 나머지를 자기 자신을 호출해 실행하는 함수이다. 모든 재귀 함수는 '더 이상 쪼개지지 않는' 최소한의 작업에 도달했을 때 답을 곧장 반환하는 조건문을 포함해야 된다. 이때, 쪼개지지 않는 가장 작은 작업들을 가리켜 재귀 호출의 <U>**기저 사례(Base case)**</U>라고 한다.

**[시간 복잡도 분석]**  
완전 탐색은 가능한 답 후보들을 모두 만들어 보기 때문에, 시간 복잡도를 계산하기 위해서는 가능한 후보의 수를 전부 세어보기만 하면 된다.

**[완전 탐색 레시피]**  
어떤 문제를 완전 탐색으로 해결하기 위해 필요한 과정은 대략 다음과 같다.
1. 완전 탐색은 존재하는 모든 답을 하나씩 검사하므로, 걸리는 시간은 가능한 답의 수에 정확히 비례한다.
2. 가능한 모든 답의 후보를 만드는 과정을 여러 개의 선택으로 나눈다.
3. 그중 하나의 조각을 선택해 답의 일부를 만들고, 나머지 답을 재귀 호출을 통해 완성한다.
4. 조각이 하나밖에 남지 않은 경우, 혹은 하나도 남지 않은 경우에는 답을 생성했으므로, 이것을 기저 사례로 선택해 처리한다.

**[이론적 배경: 재귀 호출과 부분 문제]**  
재귀 호출 주요 개념중 하나로 문제(Problem)와 부분 문제(Subproblem)의 정의가 있다.
이 정의는 뒤에 다룰 동적 계획법이나 분할 정복과 같은 중요한 디자인 패러다임을 설명하는 데 사용된다.
<br></br>

## 6.3 문제: 소풍 (문제 ID: PICNIC, 난이도: 하)
## 6.4 풀이: 소풍
## 6.5 문제: 게임판 덮기 (문제 ID: BOARDCOVER, 난이도: 하)
## 6.6 풀이: 게임판 덮기
<br>

## 6.7 최적화 문제
어떤 기준에 따라 가장 '좋은' 답을 찾아 내는 문제들을 통칭해 최적화 문제(Optimization problem)라고 부른다.  

Ex. n개의 원소 중에서 r개를 순서 없이 골라내는 방법의 수를 계산하기 (x)  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n개의 사과 중에서 r개를 골라서 무게의 합을 최대화하는 문제 (o)
<br></br>

## 6.7 최적화 문제
예제: 여행하는 외판원(Traveling Sales-man Problem, TSP) 문제  
백준 2098번 https://www.acmicpc.net/problem/2098
<br></br>

## 6.8 문제: 시계 맞추기(문제 ID: CLOCKSYNC, 난이도: 중)
## 6.9 풀이: 시계 맞추기
문제의 특성을 이용해 적절히 단순화하면 완전 탐색으로 해결할 수 있다.
<br></br>

## 6.10 많이 등장하는 완전 탐색 유형
- 주어진 원소로 만들 수 있는 모든 순열 만들기
- 주어진 원소 중 R개를 골라낼 수 있는 방법 만들기  

입력의 크기에 따라 답의 개수가 어떻게 변하는지를 알고 구현하는 방법을 연습하면 좋다.

**[모든 순열 만들기]**  
서로 다른 N개의 원소를 일렬로 줄 세운 것을 순열(Permutation)이라고 한다.
- C++ STL : next_permutation()

**[모든 조합 만들기]**  
서로 다른 N개의 원소 중에서 R개를 순서 없이 골라낸 것을 조합(Combination)이라고 한다.

**[ $2^n$가지 경우의 수 만들기 ]**  
n개의 질문에 대한 답이 예/아니오 중 하나라고 할 떄 존재할 수 있는 답의 모든 조합의 수이다.